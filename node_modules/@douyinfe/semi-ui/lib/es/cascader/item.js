import _includes from "lodash/includes";
import React, { PureComponent } from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/cascader/constants';
import isEnterPress from '@douyinfe/semi-foundation/lib/es/utils/isEnterPress';
import ConfigContext from '../configProvider/context';
import LocaleConsumer from '../locale/localeConsumer';
import { IconChevronRight, IconTick } from '@douyinfe/semi-icons';
import Spin from '../spin';
import Checkbox from '../checkbox';
const prefixcls = cssClasses.PREFIX_OPTION;
export default class Item extends PureComponent {
  constructor() {
    super(...arguments);

    this.onClick = (e, item) => {
      const {
        onItemClick
      } = this.props;

      if (item.data.disabled || 'disabled' in item && item.disabled) {
        return;
      }

      onItemClick(e, item);
    };
    /**
     * A11y: simulate item click
     */


    this.handleItemEnterPress = (keyboardEvent, item) => {
      if (isEnterPress(keyboardEvent)) {
        this.onClick(keyboardEvent, item);
      }
    };

    this.onHover = (e, item) => {
      const {
        showNext,
        onItemHover
      } = this.props;

      if (item.data.disabled) {
        return;
      }

      if (showNext === strings.SHOW_NEXT_BY_HOVER) {
        onItemHover(e, item);
      }
    };

    this.onCheckboxChange = (e, item) => {
      const {
        onItemCheckboxClick
      } = this.props; // Prevent Checkbox's click event bubbling to trigger the li click event

      e.stopPropagation();

      if (e.nativeEvent && typeof e.nativeEvent.stopImmediatePropagation === 'function') {
        e.nativeEvent.stopImmediatePropagation();
      }

      onItemCheckboxClick(item);
    };

    this.getItemStatus = key => {
      const {
        activeKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys
      } = this.props;
      const state = {
        active: false,
        selected: false,
        loading: false
      };

      if (activeKeys.has(key)) {
        state.active = true;
      }

      if (selectedKeys.has(key)) {
        state.selected = true;
      }

      if (loadingKeys.has(key) && !loadedKeys.has(key)) {
        state.loading = true;
      }

      return state;
    };

    this.renderIcon = function (type) {
      let haveMarginLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      const finalCls = style => {
        return style + (haveMarginLeft ? " ".concat(prefixcls, "-icon-left") : '');
      };

      switch (type) {
        case 'child':
          return /*#__PURE__*/React.createElement(IconChevronRight, {
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-expand"))
          });

        case 'tick':
          return /*#__PURE__*/React.createElement(IconTick, {
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-active"))
          });

        case 'loading':
          return /*#__PURE__*/React.createElement(Spin, {
            wrapperClassName: finalCls("".concat(prefixcls, "-spin-icon"))
          });

        case 'empty':
          return /*#__PURE__*/React.createElement("span", {
            "aria-hidden": true,
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-empty"))
          });

        default:
          return null;
      }
    };

    this.highlight = searchText => {
      const content = [];
      const {
        keyword,
        separator
      } = this.props;
      searchText.forEach((item, idx) => {
        if (typeof item === 'string' && _includes(item, keyword)) {
          item.split(keyword).forEach((node, index) => {
            if (index > 0) {
              content.push( /*#__PURE__*/React.createElement("span", {
                className: "".concat(prefixcls, "-label-highlight"),
                key: "".concat(index, "-").concat(idx)
              }, keyword));
            }

            content.push(node);
          });
        } else {
          content.push(item);
        }

        if (idx !== searchText.length - 1) {
          content.push(separator);
        }
      });
      return content;
    };

    this.renderFlattenOption = data => {
      const {
        multiple,
        checkedKeys,
        halfCheckedKeys
      } = this.props;
      const content = /*#__PURE__*/React.createElement("ul", {
        className: "".concat(prefixcls, "-list"),
        key: 'flatten-list'
      }, data.map(item => {
        const {
          searchText,
          key,
          disabled
        } = item;
        const className = cls(prefixcls, {
          ["".concat(prefixcls, "-flatten")]: true,
          ["".concat(prefixcls, "-disabled")]: disabled
        });
        return /*#__PURE__*/React.createElement("li", {
          role: 'menuitem',
          className: className,
          key: key,
          onClick: e => {
            this.onClick(e, item);
          },
          onKeyPress: e => this.handleItemEnterPress(e, item)
        }, /*#__PURE__*/React.createElement("span", {
          className: "".concat(prefixcls, "-label")
        }, !multiple && this.renderIcon('empty'), multiple && /*#__PURE__*/React.createElement(Checkbox, {
          onChange: e => this.onCheckboxChange(e, item),
          disabled: disabled,
          indeterminate: halfCheckedKeys.has(item.key),
          checked: checkedKeys.has(item.key),
          className: "".concat(prefixcls, "-label-checkbox")
        }), this.highlight(searchText)));
      }));
      return content;
    };
  }

  renderItem(renderData) {
    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const {
      multiple,
      checkedKeys,
      halfCheckedKeys
    } = this.props;
    let showChildItem;
    const ind = content.length;
    content.push( /*#__PURE__*/React.createElement("ul", {
      role: 'menu',
      className: "".concat(prefixcls, "-list"),
      key: renderData[0].key,
      onScroll: e => this.props.onListScroll(e, ind)
    }, renderData.map(item => {
      const {
        data,
        key,
        parentKey
      } = item;
      const {
        children,
        label,
        disabled,
        isLeaf
      } = data;
      const {
        active,
        selected,
        loading
      } = this.getItemStatus(key);
      const hasChild = Boolean(children) && children.length;
      const showExpand = hasChild || this.props.loadData && !isLeaf;

      if (active && hasChild) {
        showChildItem = item;
      }

      const className = cls(prefixcls, {
        ["".concat(prefixcls, "-active")]: active && !selected,
        ["".concat(prefixcls, "-select")]: selected && !multiple,
        ["".concat(prefixcls, "-disabled")]: disabled
      });
      const otherAriaProps = parentKey ? {
        ['aria-owns']: "cascaderItem-".concat(parentKey)
      } : {};
      return /*#__PURE__*/React.createElement("li", Object.assign({
        role: 'menuitem',
        id: "cascaderItem-".concat(key),
        "aria-expanded": active,
        "aria-haspopup": Boolean(showExpand),
        "aria-disabled": disabled
      }, otherAriaProps, {
        className: className,
        key: key,
        onClick: e => {
          this.onClick(e, item);
        },
        onKeyPress: e => this.handleItemEnterPress(e, item),
        onMouseEnter: e => {
          this.onHover(e, item);
        }
      }), /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixcls, "-label")
      }, selected && !multiple && this.renderIcon('tick'), !selected && !multiple && this.renderIcon('empty'), multiple && /*#__PURE__*/React.createElement(Checkbox, {
        onChange: e => this.onCheckboxChange(e, item),
        disabled: disabled,
        indeterminate: halfCheckedKeys.has(item.key),
        checked: checkedKeys.has(item.key),
        className: "".concat(prefixcls, "-label-checkbox")
      }), /*#__PURE__*/React.createElement("span", null, label)), showExpand ? this.renderIcon(loading ? 'loading' : 'child', true) : null);
    })));

    if (showChildItem) {
      content.concat(this.renderItem(showChildItem.children, content));
    }

    return content;
  }

  renderEmpty() {
    const {
      emptyContent
    } = this.props;
    return /*#__PURE__*/React.createElement(LocaleConsumer, {
      componentName: "Cascader"
    }, locale => /*#__PURE__*/React.createElement("ul", {
      className: "".concat(prefixcls, " ").concat(prefixcls, "-empty"),
      key: 'empty-list'
    }, /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixcls, "-label"),
      "x-semi-prop": "emptyContent"
    }, emptyContent || locale.emptyText)));
  }

  render() {
    const {
      data,
      searchable
    } = this.props;
    const {
      direction
    } = this.context;
    const isEmpty = !data || !data.length;
    let content;
    const listsCls = cls({
      ["".concat(prefixcls, "-lists")]: true,
      ["".concat(prefixcls, "-lists-rtl")]: direction === 'rtl',
      ["".concat(prefixcls, "-lists-empty")]: isEmpty
    });

    if (isEmpty) {
      content = this.renderEmpty();
    } else {
      content = searchable ? this.renderFlattenOption(data) : this.renderItem(data);
    }

    return /*#__PURE__*/React.createElement("div", {
      className: listsCls
    }, content);
  }

}
Item.contextType = ConfigContext;
Item.propTypes = {
  data: PropTypes.array,
  emptyContent: PropTypes.node,
  searchable: PropTypes.bool,
  onItemClick: PropTypes.func,
  onItemHover: PropTypes.func,
  multiple: PropTypes.bool,
  showNext: PropTypes.oneOf([strings.SHOW_NEXT_BY_CLICK, strings.SHOW_NEXT_BY_HOVER]),
  checkedKeys: PropTypes.object,
  halfCheckedKeys: PropTypes.object,
  onItemCheckboxClick: PropTypes.func,
  separator: PropTypes.string,
  keyword: PropTypes.string
};
Item.defaultProps = {
  empty: false
};