/* eslint-disable no-param-reassign */
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import ToastListFoundation from '@douyinfe/semi-foundation/lib/es/toast/toastListFoundation';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/toast/constants';
import BaseComponent from '../_base/baseComponent';
import Toast from './toast';
import '@douyinfe/semi-foundation/lib/es/toast/toast.css';
import getUuid from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import useToast from './useToast';
import CSSAnimation from '../_cssAnimation';
import cls from 'classnames';

const createBaseToast = () => {
  var _a;

  return _a = class ToastList extends BaseComponent {
    constructor(props) {
      super(props);
      this.state = {
        list: [],
        removedItems: [],
        updatedItems: []
      };
      this.foundation = new ToastListFoundation(this.adapter);
    }

    get adapter() {
      return Object.assign(Object.assign({}, super.adapter), {
        updateToast: (list, removedItems, updatedItems) => {
          this.setState({
            list,
            removedItems,
            updatedItems
          });
        }
      });
    }

    static create(opts) {
      var _a;

      const id = (_a = opts.id) !== null && _a !== void 0 ? _a : getUuid('toast'); // this.id = id;

      if (!ToastList.ref) {
        const div = document.createElement('div');

        if (!this.wrapperId) {
          this.wrapperId = getUuid('toast-wrapper').slice(0, 26);
        }

        div.className = cssClasses.WRAPPER;
        div.id = this.wrapperId;
        div.style.zIndex = String(typeof opts.zIndex === 'number' ? opts.zIndex : ToastList.defaultOpts.zIndex);
        ['top', 'left', 'bottom', 'right'].map(pos => {
          if (pos in ToastList.defaultOpts || pos in opts) {
            const val = opts[pos] ? opts[pos] : ToastList.defaultOpts[pos];
            div.style[pos] = typeof val === 'number' ? "".concat(val, "px") : val;
          }
        }); // document.body.appendChild(div);

        if (ToastList.defaultOpts.getPopupContainer) {
          const container = ToastList.defaultOpts.getPopupContainer();
          container.appendChild(div);
        } else {
          document.body.appendChild(div);
        }

        ReactDOM.render( /*#__PURE__*/React.createElement(ToastList, {
          ref: instance => ToastList.ref = instance
        }), div, () => {
          ToastList.ref.add(Object.assign(Object.assign({}, opts), {
            id
          }));
        });
      } else {
        const node = document.querySelector("#".concat(this.wrapperId));
        ['top', 'left', 'bottom', 'right'].map(pos => {
          if (pos in opts) {
            node.style[pos] = typeof opts[pos] === 'number' ? "".concat(opts[pos], "px") : opts[pos];
          }
        });

        if (ToastList.ref.has(id)) {
          ToastList.ref.update(id, Object.assign(Object.assign({}, opts), {
            id
          }));
        } else {
          ToastList.ref.add(Object.assign(Object.assign({}, opts), {
            id
          }));
        }
      }

      return id;
    }

    static close(id) {
      if (ToastList.ref) {
        ToastList.ref.remove(id);
      }
    }

    static destroyAll() {
      if (ToastList.ref) {
        ToastList.ref.destroyAll();
        const wrapper = document.querySelector("#".concat(this.wrapperId));
        ReactDOM.unmountComponentAtNode(wrapper);
        wrapper && wrapper.parentNode.removeChild(wrapper);
        ToastList.ref = null;
        this.wrapperId = null;
      }
    }

    static getWrapperId() {
      return this.wrapperId;
    }

    static info(opts) {
      if (typeof opts === 'string') {
        opts = {
          content: opts
        };
      }

      return this.create(Object.assign(Object.assign(Object.assign({}, ToastList.defaultOpts), opts), {
        type: 'info'
      }));
    }

    static warning(opts) {
      if (typeof opts === 'string') {
        opts = {
          content: opts
        };
      }

      return this.create(Object.assign(Object.assign(Object.assign({}, ToastList.defaultOpts), opts), {
        type: 'warning'
      }));
    }

    static error(opts) {
      if (typeof opts === 'string') {
        opts = {
          content: opts
        };
      }

      return this.create(Object.assign(Object.assign(Object.assign({}, ToastList.defaultOpts), opts), {
        type: 'error'
      }));
    }

    static success(opts) {
      if (typeof opts === 'string') {
        opts = {
          content: opts
        };
      }

      return this.create(Object.assign(Object.assign(Object.assign({}, ToastList.defaultOpts), opts), {
        type: 'success'
      }));
    }

    static config(opts) {
      ['top', 'left', 'bottom', 'right'].forEach(pos => {
        if (pos in opts) {
          ToastList.defaultOpts[pos] = opts[pos];
        }
      });

      if (typeof opts.zIndex === 'number') {
        ToastList.defaultOpts.zIndex = opts.zIndex;
      }

      if (typeof opts.duration === 'number') {
        ToastList.defaultOpts.duration = opts.duration;
      }

      if (typeof opts.getPopupContainer === 'function') {
        ToastList.defaultOpts.getPopupContainer = opts.getPopupContainer;
      }
    }

    has(id) {
      return this.foundation.hasToast(id);
    }

    add(opts) {
      return this.foundation.addToast(opts);
    }

    update(id, opts) {
      return this.foundation.updateToast(id, opts);
    }

    remove(id) {
      return this.foundation.removeToast(id);
    }

    destroyAll() {
      return this.foundation.destroyAll();
    }

    render() {
      let {
        list
      } = this.state;
      const {
        removedItems,
        updatedItems
      } = this.state;
      list = Array.from(new Set([...list, ...removedItems]));
      const updatedIds = updatedItems.map(_ref => {
        let {
          id
        } = _ref;
        return id;
      });

      const refFn = toast => {
        var _a;

        if (((_a = toast === null || toast === void 0 ? void 0 : toast.foundation) === null || _a === void 0 ? void 0 : _a._id) && updatedIds.includes(toast.foundation._id)) {
          toast.foundation.setState({
            duration: toast.props.duration
          });
          toast.foundation.restartCloseTimer();
        }
      };

      return /*#__PURE__*/React.createElement(React.Fragment, null, list.map((item, index) => {
        const isRemoved = removedItems.find(removedItem => removedItem.id === item.id) !== undefined;
        return /*#__PURE__*/React.createElement(CSSAnimation, {
          key: item.id,
          motion: item.motion,
          animationState: isRemoved ? "leave" : "enter",
          startClassName: isRemoved ? "".concat(cssClasses.PREFIX, "-animation-hide") : "".concat(cssClasses.PREFIX, "-animation-show")
        }, _ref2 => {
          let {
            animationClassName,
            animationEventsNeedBind,
            isAnimating
          } = _ref2;
          return isRemoved && !isAnimating ? null : /*#__PURE__*/React.createElement(Toast, Object.assign({}, item, {
            className: cls({
              [item.className]: Boolean(item.className),
              [animationClassName]: true
            })
          }, animationEventsNeedBind, {
            style: Object.assign({}, item.style),
            close: id => this.remove(id),
            ref: refFn
          }));
        });
      }));
    }

  }, _a.defaultOpts = {
    motion: true,
    zIndex: 1010,
    content: ''
  }, _a.propTypes = {
    content: PropTypes.node,
    duration: PropTypes.number,
    onClose: PropTypes.func,
    icon: PropTypes.node,
    direction: PropTypes.oneOf(strings.directions)
  }, _a.defaultProps = {}, _a;
};

export class ToastFactory {
  static create(config) {
    const newToast = createBaseToast();
    newToast.useToast = useToast;
    config && newToast.config(config);
    return newToast;
  }

}
export default ToastFactory.create();