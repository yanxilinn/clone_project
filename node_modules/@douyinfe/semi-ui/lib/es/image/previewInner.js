import _isFunction from "lodash/isFunction";
import _isEqual from "lodash/isEqual";

/* eslint-disable jsx-a11y/no-static-element-interactions */
import React from "react";
import BaseComponent from "../_base/baseComponent";
import PropTypes from "prop-types";
import { cssClasses } from '@douyinfe/semi-foundation/lib/es/image/constants';
import cls from "classnames";
import Portal from "../_portal";
import { IconArrowLeft, IconArrowRight } from "@douyinfe/semi-icons";
import Header from "./previewHeader";
import Footer from "./previewFooter";
import PreviewImage from "./previewImage";
import PreviewInnerFoundation from '@douyinfe/semi-foundation/lib/es/image/previewInnerFoundation';
import { PreviewContext } from "./previewContext";
const prefixCls = cssClasses.PREFIX;
let startMouseDown = {
  x: 0,
  y: 0
};
let mouseActiveTime = null;
let stopTiming = false;
let timer = null; // let bodyOverflowValue = document.body.style.overflow;

export default class PreviewInner extends BaseComponent {
  constructor(props) {
    super(props);

    this.viewVisibleChange = () => {
      this.foundation.handleViewVisibleChange();
    };

    this.handleSwitchImage = direction => {
      this.foundation.handleSwitchImage(direction);
    };

    this.handleDownload = () => {
      this.foundation.handleDownload();
    };

    this.handlePreviewClose = () => {
      this.foundation.handlePreviewClose();
    };

    this.handleAdjustRatio = type => {
      this.foundation.handleAdjustRatio(type);
    };

    this.handleRotateImage = direction => {
      this.foundation.handleRotateImage(direction);
    };

    this.handleZoomImage = newZoom => {
      this.foundation.handleZoomImage(newZoom);
    };

    this.handleMouseUp = e => {
      this.foundation.handleMouseUp(e.nativeEvent);
    };

    this.handleMouseMove = e => {
      this.foundation.handleMouseMove(e);
    };

    this.handleMouseEvent = (e, event) => {
      this.foundation.handleMouseMoveEvent(e, event);
    };

    this.handleKeyDown = e => {
      this.foundation.handleKeyDown(e);
    };

    this.onImageError = () => {
      this.foundation.preloadSingleImage();
    };

    this.onImageLoad = src => {
      this.foundation.onImageLoad(src);
    };

    this.handleMouseDown = e => {
      this.foundation.handleMouseDown(e);
    };

    this.handleRatio = type => {
      this.foundation.handleRatio(type);
    };

    this.state = {
      imgSrc: [],
      imgLoadStatus: new Map(),
      zoom: 0.1,
      currentIndex: 0,
      ratio: "adaptation",
      rotation: 0,
      viewerVisible: true,
      visible: false,
      preloadAfterVisibleChange: true,
      direction: ""
    };
    this.foundation = new PreviewInnerFoundation(this.adapter);
    this.bodyOverflow = '';
    this.originBodyWidth = '100%';
    this.scrollBarWidth = 0;
  }

  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      getIsInGroup: () => this.isInGroup(),
      disabledBodyScroll: () => {
        const {
          getPopupContainer
        } = this.props;
        this.bodyOverflow = document.body.style.overflow || '';

        if (!getPopupContainer && this.bodyOverflow !== 'hidden') {
          document.body.style.overflow = 'hidden';
          document.body.style.width = "calc(".concat(this.originBodyWidth || '100%', " - ").concat(this.scrollBarWidth, "px)");
        }
      },
      enabledBodyScroll: () => {
        const {
          getPopupContainer
        } = this.props;

        if (!getPopupContainer && this.bodyOverflow !== 'hidden') {
          document.body.style.overflow = this.bodyOverflow;
          document.body.style.width = this.originBodyWidth;
        }
      },
      notifyChange: (index, direction) => {
        const {
          onChange,
          onPrev,
          onNext
        } = this.props;
        _isFunction(onChange) && onChange(index);

        if (direction === "prev") {
          onPrev && onPrev(index);
        } else {
          onNext && onNext(index);
        }
      },
      notifyZoom: (zoom, increase) => {
        const {
          onZoomIn,
          onZoomOut
        } = this.props;

        if (increase) {
          _isFunction(onZoomIn) && onZoomIn(zoom);
        } else {
          _isFunction(onZoomOut) && onZoomOut(zoom);
        }
      },
      notifyClose: () => {
        const {
          onClose
        } = this.props;
        _isFunction(onClose) && onClose();
      },
      notifyVisibleChange: visible => {
        const {
          onVisibleChange
        } = this.props;
        _isFunction(onVisibleChange) && onVisibleChange(visible);
      },
      notifyRatioChange: type => {
        const {
          onRatioChange
        } = this.props;
        _isFunction(onRatioChange) && onRatioChange(type);
      },
      notifyRotateChange: angle => {
        const {
          onRotateLeft
        } = this.props;
        _isFunction(onRotateLeft) && onRotateLeft(angle);
      },
      notifyDownload: (src, index) => {
        const {
          onDownload
        } = this.props;
        _isFunction(onDownload) && onDownload(src, index);
      },
      registerKeyDownListener: () => {
        window && window.addEventListener("keydown", this.handleKeyDown);
      },
      unregisterKeyDownListener: () => {
        window && window.removeEventListener("keydown", this.handleKeyDown);
      },
      getMouseActiveTime: () => {
        return mouseActiveTime;
      },
      getStopTiming: () => {
        return stopTiming;
      },
      setStopTiming: value => {
        stopTiming = value;
      },
      getStartMouseDown: () => {
        return startMouseDown;
      },
      setStartMouseDown: (x, y) => {
        startMouseDown = {
          x,
          y
        };
      },
      setMouseActiveTime: time => {
        mouseActiveTime = time;
      }
    });
  }

  static getDerivedStateFromProps(props, state) {
    const willUpdateStates = {};
    let src = [];

    if (props.visible) {
      // if src in props
      src = Array.isArray(props.src) ? props.src : [props.src];
    }

    if (!_isEqual(src, state.imgSrc)) {
      willUpdateStates.imgSrc = src;
    }

    if (props.visible !== state.visible) {
      willUpdateStates.visible = props.visible;

      if (props.visible) {
        willUpdateStates.preloadAfterVisibleChange = true;
      }
    }

    if ("currentIndex" in props && props.currentIndex !== state.currentIndex) {
      willUpdateStates.currentIndex = props.currentIndex;
    }

    return willUpdateStates;
  }

  static getScrollbarWidth() {
    if (globalThis && Object.prototype.toString.call(globalThis) === '[object Window]') {
      return window.innerWidth - document.documentElement.clientWidth;
    }

    return 0;
  }

  componentDidMount() {
    this.scrollBarWidth = PreviewInner.getScrollbarWidth();
    this.originBodyWidth = document.body.style.width;

    if (this.props.visible) {
      this.foundation.beforeShow();
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.visible !== this.props.visible && this.props.visible) {
      mouseActiveTime = new Date().getTime();
      timer && clearInterval(timer);
      timer = setInterval(this.viewVisibleChange, 1000);
    } // hide => show


    if (!prevProps.visible && this.props.visible) {
      this.foundation.beforeShow();
    } // show => hide


    if (prevProps.visible && !this.props.visible) {
      this.foundation.afterHide();
    }
  }

  componentWillUnmount() {
    timer && clearInterval(timer);
  }

  isInGroup() {
    return Boolean(this.context && this.context.isGroup);
  }

  render() {
    const {
      getPopupContainer,
      zIndex,
      visible,
      className,
      style,
      infinite,
      zoomStep,
      crossOrigin,
      prevTip,
      nextTip,
      zoomInTip,
      zoomOutTip,
      rotateTip,
      downloadTip,
      adaptiveTip,
      originTip,
      showTooltip,
      disableDownload,
      renderPreviewMenu,
      renderHeader
    } = this.props;
    const {
      currentIndex,
      imgSrc,
      zoom,
      ratio,
      rotation,
      viewerVisible
    } = this.state;
    let wrapperStyle = {
      zIndex
    };

    if (getPopupContainer) {
      wrapperStyle = {
        zIndex,
        position: "static"
      };
    }

    const previewPrefixCls = "".concat(prefixCls, "-preview");
    const previewWrapperCls = cls(previewPrefixCls, {
      ["".concat(prefixCls, "-hide")]: !visible,
      ["".concat(previewPrefixCls, "-popup")]: getPopupContainer
    }, className);
    const hideViewerCls = !viewerVisible ? "".concat(previewPrefixCls, "-hide") : "";
    const total = imgSrc.length;
    const showPrev = total !== 1 && (infinite || currentIndex !== 0);
    const showNext = total !== 1 && (infinite || currentIndex !== total - 1);
    return /*#__PURE__*/React.createElement(Portal, {
      getPopupContainer: getPopupContainer,
      style: wrapperStyle
    }, visible &&
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events,jsx-a11y/no-static-element-interactions
    React.createElement("div", {
      className: previewWrapperCls,
      style: style,
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onMouseMove: this.handleMouseMove,
      onMouseOver: e => this.handleMouseEvent(e.nativeEvent, "over"),
      onMouseOut: e => this.handleMouseEvent(e.nativeEvent, "out")
    }, /*#__PURE__*/React.createElement(Header, {
      className: cls(hideViewerCls),
      onClose: this.handlePreviewClose,
      renderHeader: renderHeader
    }), /*#__PURE__*/React.createElement(PreviewImage, {
      src: imgSrc[currentIndex],
      onZoom: this.handleZoomImage,
      disableDownload: disableDownload,
      setRatio: this.handleRatio,
      zoom: zoom,
      ratio: ratio,
      zoomStep: zoomStep,
      rotation: rotation,
      crossOrigin: crossOrigin,
      onError: this.onImageError,
      onLoad: this.onImageLoad
    }), showPrev &&
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    React.createElement("div", {
      className: cls("".concat(previewPrefixCls, "-icon"), "".concat(previewPrefixCls, "-prev"), hideViewerCls),
      onClick: () => this.handleSwitchImage("prev")
    }, /*#__PURE__*/React.createElement(IconArrowLeft, {
      size: "large"
    })), showNext &&
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    React.createElement("div", {
      className: cls("".concat(previewPrefixCls, "-icon"), "".concat(previewPrefixCls, "-next"), hideViewerCls),
      onClick: () => this.handleSwitchImage("next")
    }, /*#__PURE__*/React.createElement(IconArrowRight, {
      size: "large"
    })), /*#__PURE__*/React.createElement(Footer, {
      className: hideViewerCls,
      totalNum: total,
      curPage: currentIndex + 1,
      disabledPrev: !showPrev,
      disabledNext: !showNext,
      zoom: zoom * 100,
      step: zoomStep * 100,
      showTooltip: showTooltip,
      ratio: ratio,
      prevTip: prevTip,
      nextTip: nextTip,
      zoomInTip: zoomInTip,
      zoomOutTip: zoomOutTip,
      rotateTip: rotateTip,
      downloadTip: downloadTip,
      disableDownload: disableDownload,
      adaptiveTip: adaptiveTip,
      originTip: originTip,
      onPrev: () => this.handleSwitchImage("prev"),
      onNext: () => this.handleSwitchImage("next"),
      onZoomIn: this.handleZoomImage,
      onZoomOut: this.handleZoomImage,
      onDownload: this.handleDownload,
      onRotate: this.handleRotateImage,
      onAdjustRatio: this.handleAdjustRatio,
      renderPreviewMenu: renderPreviewMenu
    })));
  }

}
PreviewInner.contextType = PreviewContext;
PreviewInner.propTypes = {
  style: PropTypes.object,
  className: PropTypes.string,
  visible: PropTypes.bool,
  src: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  currentIndex: PropTypes.number,
  defaultIndex: PropTypes.number,
  defaultVisible: PropTypes.bool,
  maskClosable: PropTypes.bool,
  closable: PropTypes.bool,
  zoomStep: PropTypes.number,
  infinite: PropTypes.bool,
  showTooltip: PropTypes.bool,
  closeOnEsc: PropTypes.bool,
  prevTip: PropTypes.string,
  nextTip: PropTypes.string,
  zoomInTip: PropTypes.string,
  zoomOutTip: PropTypes.string,
  downloadTip: PropTypes.string,
  adaptiveTip: PropTypes.string,
  originTip: PropTypes.string,
  lazyLoad: PropTypes.bool,
  preLoad: PropTypes.bool,
  preLoadGap: PropTypes.number,
  disableDownload: PropTypes.bool,
  viewerVisibleDelay: PropTypes.number,
  zIndex: PropTypes.number,
  renderHeader: PropTypes.func,
  renderPreviewMenu: PropTypes.func,
  getPopupContainer: PropTypes.func,
  onVisibleChange: PropTypes.func,
  onChange: PropTypes.func,
  onClose: PropTypes.func,
  onZoomIn: PropTypes.func,
  onZoomOut: PropTypes.func,
  onPrev: PropTypes.func,
  onNext: PropTypes.func,
  onDownload: PropTypes.func,
  onRatioChange: PropTypes.func,
  onRotateLeft: PropTypes.func
};
PreviewInner.defaultProps = {
  showTooltip: false,
  zoomStep: 0.1,
  infinite: false,
  closeOnEsc: true,
  lazyLoad: false,
  preLoad: true,
  preLoadGap: 2,
  zIndex: 1000,
  maskClosable: true,
  viewerVisibleDelay: 10000
};