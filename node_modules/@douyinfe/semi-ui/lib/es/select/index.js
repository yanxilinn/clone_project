import _isNumber from "lodash/isNumber";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _isString from "lodash/isString";
import _isEqual from "lodash/isEqual";

/* eslint-disable max-len */

/* eslint-disable max-lines-per-function */
import React, { Fragment } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import SelectFoundation from '@douyinfe/semi-foundation/lib/es/select/foundation';
import { cssClasses, strings, numbers } from '@douyinfe/semi-foundation/lib/es/select/constants';
import BaseComponent from '../_base/baseComponent';
import Tag from '../tag/index';
import TagGroup from '../tag/group';
import LocaleConsumer from '../locale/localeConsumer';
import Popover from '../popover/index';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import Event from '@douyinfe/semi-foundation/lib/es/utils/Event';
import { FixedSizeList as List } from 'react-window';
import { getOptionsFromGroup } from './utils';
import VirtualRow from './virtualRow';
import Input from '../input/index';
import Option from './option';
import OptionGroup from './optionGroup';
import Spin from '../spin';
import Trigger from '../trigger';
import { IconChevronDown, IconClear } from '@douyinfe/semi-icons';
import { isSemiIcon, getFocusableElements, getActiveElement } from '../_utils';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { getUuidShort } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import '@douyinfe/semi-foundation/lib/es/select/select.css';
const prefixcls = cssClasses.PREFIX;
const key = 0; // Notes: Use the label of the option as the identifier, that is, the option in Select, the value is allowed to be the same, but the label must be unique

class Select extends BaseComponent {
  constructor(props) {
    super(props);

    this.setOptionContainerEl = node => this.optionContainerEl = {
      current: node
    };

    this.handleInputChange = value => this.foundation.handleInputChange(value);

    this.getTagItem = (item, i, renderSelectedItem) => {
      const {
        size,
        disabled: selectDisabled
      } = this.props;
      const label = item[0];
      const {
        value
      } = item[1];
      const disabled = item[1].disabled || selectDisabled;

      const onClose = (tagContent, e) => {
        if (e && typeof e.preventDefault === 'function') {
          e.preventDefault(); // make sure that tag will not hidden immediately in controlled mode
        }

        this.foundation.removeTag({
          label,
          value
        });
      };

      const {
        content,
        isRenderInTag
      } = renderSelectedItem(item[1], {
        index: i,
        disabled,
        onClose
      });
      const basic = {
        disabled,
        closable: !disabled,
        onClose
      };

      if (isRenderInTag) {
        return /*#__PURE__*/React.createElement(Tag, Object.assign({}, basic, {
          color: "white",
          size: size || 'large',
          key: value,
          tabIndex: -1
        }), content);
      } else {
        return /*#__PURE__*/React.createElement(Fragment, {
          key: value
        }, content);
      }
    };

    this.state = {
      isOpen: false,
      isFocus: false,
      options: [],
      selections: new Map(),
      dropdownMinWidth: null,
      optionKey: key,
      inputValue: '',
      showInput: false,
      focusIndex: props.defaultActiveFirstOption ? 0 : -1,
      keyboardEventSet: {},
      optionGroups: [],
      isHovering: false,
      isFocusInContainer: false,
      isFullTags: false
    };
    /* Generate random string */

    this.selectOptionListID = '';
    this.selectID = '';
    this.virtualizeListRef = /*#__PURE__*/React.createRef();
    this.inputRef = /*#__PURE__*/React.createRef();
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.optionContainerEl = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.onSelect = this.onSelect.bind(this);
    this.onClear = this.onClear.bind(this);
    this.onMouseEnter = this.onMouseEnter.bind(this);
    this.onMouseLeave = this.onMouseLeave.bind(this);
    this.renderOption = this.renderOption.bind(this);
    this.onKeyPress = this.onKeyPress.bind(this);
    this.eventManager = new Event();
    this.foundation = new SelectFoundation(this.adapter);
    warning('optionLabelProp' in this.props, '[Semi Select] \'optionLabelProp\' has already been deprecated, please use \'renderSelectedItem\' instead.');
    warning('labelInValue' in this.props, '[Semi Select] \'labelInValue\' has already been deprecated, please use \'onChangeWithObject\' instead.');
  }

  get adapter() {
    var _this = this;

    const keyboardAdapter = {
      registerKeyDown: cb => {
        const keyboardEventSet = {
          onKeyDown: cb
        };
        this.setState({
          keyboardEventSet
        });
      },
      unregisterKeyDown: () => {
        this.setState({
          keyboardEventSet: {}
        });
      },
      updateFocusIndex: focusIndex => {
        this.setState({
          focusIndex
        });
      },
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      scrollToFocusOption: () => {}
    };
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      toggleInputShow: (showInput, cb) => {
        this.setState({
          showInput
        }, () => {
          cb();
        });
      },
      focusInput: () => {
        const {
          preventScroll
        } = this.props;

        if (this.inputRef && this.inputRef.current) {
          this.inputRef.current.focus({
            preventScroll
          });
        }
      }
    };
    const multipleAdapter = {
      notifyMaxLimit: option => this.props.onExceed(option),
      getMaxLimit: () => this.props.max,
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current; // eslint-disable-next-line react/no-find-dom-node

          const optionsDom = ReactDOM.findDOMNode(optionInstance); // let isInPanel = optionsDom && optionsDom.contains(e.target);
          // let isInTrigger = triggerDom && triggerDom.contains(e.target);

          if (optionsDom && !optionsDom.contains(e.target) && triggerDom && !triggerDom.contains(e.target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        if (this.clickOutsideHandler) {
          document.removeEventListener('mousedown', this.clickOutsideHandler, false);
          this.clickOutsideHandler = null;
        }
      },
      rePositionDropdown: () => {
        let {
          optionKey
        } = this.state;
        optionKey = optionKey + 1;
        this.setState({
          optionKey
        });
      },
      notifyDeselect: (value, option) => {
        delete option._parentGroup;
        this.props.onDeselect(value, option);
      }
    };
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), keyboardAdapter), filterAdapter), multipleAdapter), {
      on: (eventName, eventCallback) => this.eventManager.on(eventName, eventCallback),
      off: eventName => this.eventManager.off(eventName),
      once: (eventName, eventCallback) => this.eventManager.once(eventName, eventCallback),
      emit: eventName => this.eventManager.emit(eventName),
      // Collect all subitems, each item is visible by default when collected, and is not selected
      getOptionsFromChildren: function () {
        let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.children;
        let optionGroups = [];
        let options = [];
        const {
          optionList
        } = _this.props;

        if (optionList && optionList.length) {
          options = optionList.map((itemOpt, index) => Object.assign({
            _show: true,
            _selected: false,
            _scrollIndex: index
          }, itemOpt));
          optionGroups[0] = {
            children: options,
            label: ''
          };
        } else {
          const result = getOptionsFromGroup(children);
          optionGroups = result.optionGroups;
          options = result.options;
        }

        _this.setState({
          optionGroups
        });

        return options;
      },
      updateOptions: options => {
        this.setState({
          options
        });
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        });
      },
      closeMenu: () => {
        this.setState({
          isOpen: false
        });
      },
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      updateSelection: selections => {
        this.setState({
          selections
        });
      },
      // clone Map, important!!!, prevent unexpected modify on state
      getSelections: () => new Map(this.state.selections),
      notifyChange: value => {
        this.props.onChange(value);
      },
      notifySelect: (value, option) => {
        delete option._parentGroup;
        this.props.onSelect(value, option);
      },
      notifyDropdownVisibleChange: visible => {
        this.props.onDropdownVisibleChange(visible);
      },
      notifySearch: input => {
        this.props.onSearch(input);
      },
      notifyCreate: input => {
        this.props.onCreate(input);
      },
      notifyMouseEnter: e => {
        this.props.onMouseEnter(e);
      },
      notifyMouseLeave: e => {
        this.props.onMouseLeave(e);
      },
      notifyFocus: event => {
        this.props.onFocus(event);
      },
      notifyBlur: event => {
        this.props.onBlur(event);
      },
      notifyClear: () => {
        this.props.onClear();
      },
      notifyListScroll: e => {
        this.props.onListScroll(e);
      },
      updateHovering: isHovering => {
        this.setState({
          isHovering
        });
      },
      updateFocusState: isFocus => {
        this.setState({
          isFocus
        });
      },
      focusTrigger: () => {
        try {
          const {
            preventScroll
          } = this.props;
          const el = this.triggerRef.current;
          el.focus({
            preventScroll
          });
        } catch (error) {}
      },
      getContainer: () => {
        return this.optionContainerEl && this.optionContainerEl.current;
      },
      getFocusableElements: node => {
        return getFocusableElements(node);
      },
      getActiveElement: () => {
        return getActiveElement();
      },
      setIsFocusInContainer: isFocusInContainer => {
        this.setState({
          isFocusInContainer
        });
      },
      getIsFocusInContainer: () => {
        return this.state.isFocusInContainer;
      },
      updateScrollTop: index => {
        // eslint-disable-next-line max-len
        let optionClassName = ".".concat(prefixcls, "-option-selected");

        if (index !== undefined) {
          optionClassName = ".".concat(prefixcls, "-option:nth-child(").concat(index, ")");
        }

        let destNode = document.querySelector("#".concat(prefixcls, "-").concat(this.selectOptionListID, " ").concat(optionClassName));

        if (Array.isArray(destNode)) {
          // eslint-disable-next-line prefer-destructuring
          destNode = destNode[0];
        }

        if (destNode) {
          /**
           * Scroll the first selected item into view.
           * The reason why ScrollIntoView is not used here is that it may cause page to move.
           */
          const destParent = destNode.parentNode;
          destParent.scrollTop = destNode.offsetTop - destParent.offsetTop - destParent.clientHeight / 2 + destNode.clientHeight / 2;
        }
      }
    });
  }

  componentDidMount() {
    this.foundation.init();
    this.selectOptionListID = getUuidShort();
    this.selectID = this.props.id || getUuidShort();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  componentDidUpdate(prevProps, prevState) {
    const prevChildrenKeys = React.Children.toArray(prevProps.children).map(child => child.key);
    const nowChildrenKeys = React.Children.toArray(this.props.children).map(child => child.key);
    let isOptionsChanged = false;

    if (!_isEqual(prevChildrenKeys, nowChildrenKeys) || !_isEqual(prevProps.optionList, this.props.optionList)) {
      isOptionsChanged = true;
      this.foundation.handleOptionListChange();
    } // Add isOptionChanged: There may be cases where the value is unchanged, but the optionList is updated. At this time, the label corresponding to the value may change, and the selected item needs to be updated


    if (!_isEqual(this.props.value, prevProps.value) || isOptionsChanged) {
      if ('value' in this.props) {
        this.foundation.handleValueChange(this.props.value);
      } else {
        this.foundation.handleOptionListChangeHadDefaultValue();
      }
    }
  }

  renderInput() {
    const {
      size,
      multiple,
      disabled,
      inputProps,
      filter
    } = this.props;

    const inputPropsCls = _get(inputProps, 'className');

    const inputcls = cls("".concat(prefixcls, "-input"), {
      ["".concat(prefixcls, "-input-single")]: !multiple,
      ["".concat(prefixcls, "-input-multiple")]: multiple
    }, inputPropsCls);
    const {
      inputValue,
      focusIndex
    } = this.state;
    const selectInputProps = Object.assign({
      value: inputValue,
      disabled,
      className: inputcls,
      onChange: this.handleInputChange
    }, inputProps);
    let style = {}; // Multiple choice mode

    if (multiple) {
      style = {
        width: inputValue ? "".concat(inputValue.length * 16, "px") : '2px'
      };
      selectInputProps.style = style;
    }

    return /*#__PURE__*/React.createElement(Input, Object.assign({
      ref: this.inputRef,
      size: size,
      "aria-activedescendant": focusIndex !== -1 ? "".concat(this.selectID, "-option-").concat(focusIndex) : '',
      onFocus: e => {
        // if multiple and filter, when use tab key to let select get focus
        // need to manual update state isFocus to let the focus style take effect
        if (multiple && Boolean(filter)) {
          this.setState({
            isFocus: true
          });
        } // prevent event bubbling which will fire trigger onFocus event


        e.stopPropagation(); // e.nativeEvent.stopImmediatePropagation();
      },
      onBlur: e => this.foundation.handleInputBlur(e)
    }, selectInputProps));
  }

  close() {
    this.foundation.close();
  }

  open() {
    this.foundation.open();
  }

  clearInput() {
    this.foundation.clearInput();
  }

  selectAll() {
    this.foundation.selectAll();
  }

  deselectAll() {
    this.foundation.clearSelected();
  }

  focus() {
    this.foundation.focus();
  }

  onSelect(option, optionIndex, e) {
    this.foundation.onSelect(option, optionIndex, e);
  }

  onClear(e) {
    e.nativeEvent.stopImmediatePropagation();
    this.foundation.handleClearClick(e);
  }

  renderEmpty() {
    return /*#__PURE__*/React.createElement(Option, {
      empty: true,
      emptyContent: this.props.emptyContent
    });
  }

  renderLoading() {
    const loadingWrapperCls = "".concat(prefixcls, "-loading-wrapper");
    return /*#__PURE__*/React.createElement("div", {
      className: loadingWrapperCls
    }, /*#__PURE__*/React.createElement(Spin, null));
  }

  renderOption(option, optionIndex, style) {
    const {
      focusIndex,
      inputValue
    } = this.state;
    const {
      renderOptionItem
    } = this.props;
    let optionContent;
    const isFocused = optionIndex === focusIndex;
    let optionStyle = style || {};

    if (option.style) {
      optionStyle = Object.assign(Object.assign({}, optionStyle), option.style);
    }

    if (option._inputCreateOnly) {
      optionContent = this.renderCreateOption(option, isFocused, optionIndex, style);
    } else {
      // use another name to make sure that 'key' in optionList still exist when we call onChange
      if ('key' in option) {
        option._keyInOptionList = option.key;
      }

      optionContent = /*#__PURE__*/React.createElement(Option, Object.assign({
        showTick: true
      }, option, {
        selected: option._selected,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        focused: isFocused,
        onMouseEnter: () => this.onOptionHover(optionIndex),
        style: optionStyle,
        key: option.key || option.label + option.value + optionIndex,
        renderOptionItem: renderOptionItem,
        inputValue: inputValue,
        id: "".concat(this.selectID, "-option-").concat(optionIndex)
      }), option.label);
    }

    return optionContent;
  }

  renderCreateOption(option, isFocused, optionIndex, style) {
    const {
      renderCreateItem
    } = this.props; // default render method

    if (typeof renderCreateItem === 'undefined') {
      const defaultCreateItem = /*#__PURE__*/React.createElement(Option, Object.assign({
        key: option.key || option.label + option.value,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        onMouseEnter: () => this.onOptionHover(optionIndex),
        showTick: true
      }, option, {
        focused: isFocused,
        style: style
      }), /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "Select"
      }, locale => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixcls, "-create-tips")
      }, locale.createText), option.value)));
      return defaultCreateItem;
    }

    const customCreateItem = renderCreateItem(option.value, isFocused);
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/interactive-supports-focus
      React.createElement("div", {
        role: "button",
        "aria-label": "Use the input box to create an optional item",
        onClick: e => this.onSelect(option, optionIndex, e),
        key: option.key || option.label
      }, customCreateItem)
    );
  }

  onOptionHover(optionIndex) {
    this.foundation.handleOptionMouseEnter(optionIndex);
  }

  renderWithGroup(visibleOptions) {
    const content = [];
    const groupStatus = new Map();
    visibleOptions.forEach((option, optionIndex) => {
      const parentGroup = option._parentGroup;
      const optionContent = this.renderOption(option, optionIndex);

      if (parentGroup && !groupStatus.has(parentGroup.label)) {
        // when use with OptionGroup and group content not already insert
        const groupContent = /*#__PURE__*/React.createElement(OptionGroup, Object.assign({}, parentGroup, {
          key: parentGroup.label
        }));
        groupStatus.set(parentGroup.label, true);
        content.push(groupContent);
      }

      content.push(optionContent);
    });
    return content;
  }

  renderVirtualizeList(visibleOptions) {
    const {
      virtualize
    } = this.props;
    const {
      direction
    } = this.context;
    const {
      height,
      width,
      itemSize
    } = virtualize;
    return /*#__PURE__*/React.createElement(List, {
      ref: this.virtualizeListRef,
      height: height || numbers.LIST_HEIGHT,
      itemCount: visibleOptions.length,
      itemSize: itemSize,
      itemData: {
        visibleOptions,
        renderOption: this.renderOption
      },
      width: width || '100%',
      style: {
        direction
      }
    }, VirtualRow);
  }

  renderOptions(children) {
    const {
      dropdownMinWidth,
      options,
      selections
    } = this.state;
    const {
      maxHeight,
      dropdownClassName,
      dropdownStyle,
      outerTopSlot,
      innerTopSlot,
      outerBottomSlot,
      innerBottomSlot,
      loading,
      virtualize,
      multiple
    } = this.props; // Do a filter first, instead of directly judging in forEach, so that the focusIndex can correspond to

    const visibleOptions = options.filter(item => item._show);
    let listContent = this.renderWithGroup(visibleOptions);

    if (virtualize) {
      listContent = this.renderVirtualizeList(visibleOptions);
    }

    const style = Object.assign({
      minWidth: dropdownMinWidth
    }, dropdownStyle);
    const optionListCls = cls({
      ["".concat(prefixcls, "-option-list")]: true,
      ["".concat(prefixcls, "-option-list-chosen")]: selections.size
    });
    const isEmpty = !options.length || !options.some(item => item._show);
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React.createElement("div", {
        id: "".concat(prefixcls, "-").concat(this.selectOptionListID),
        className: cls("".concat(prefixcls, "-option-list-wrapper"), dropdownClassName),
        style: style,
        ref: this.setOptionContainerEl,
        onKeyDown: e => this.foundation.handleContainerKeyDown(e)
      }, outerTopSlot, /*#__PURE__*/React.createElement("div", {
        style: {
          maxHeight: "".concat(maxHeight, "px")
        },
        className: optionListCls,
        role: "listbox",
        "aria-multiselectable": multiple,
        onScroll: e => this.foundation.handleListScroll(e)
      }, innerTopSlot, loading ? this.renderLoading() : isEmpty ? this.renderEmpty() : listContent, innerBottomSlot), outerBottomSlot)
    );
  }

  renderSingleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      placeholder
    } = this.props;
    const {
      showInput,
      inputValue
    } = this.state;
    let renderText = '';
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => optionNode.label;
    }

    if (selectedItems.length) {
      const selectedItem = selectedItems[0][1];
      renderText = renderSelectedItem(selectedItem);
    }

    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !renderText && renderText !== 0,
      ["".concat(prefixcls, "-selection-text-hide")]: inputValue && showInput,
      ["".concat(prefixcls, "-selection-text-inactive")]: !inputValue && showInput // Stack Input & RenderText(opacity 0.4)

    });
    const contentWrapperCls = "".concat(prefixcls, "-content-wrapper");
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, /*#__PURE__*/React.createElement("span", {
      className: spanCls,
      "x-semi-prop": "placeholder"
    }, renderText || renderText === 0 ? renderText : placeholder), filterable && showInput ? this.renderInput() : null));
  }

  renderMultipleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      showRestTagsPopover,
      restTagsPopoverProps,
      placeholder,
      maxTagCount
    } = this.props;
    const {
      inputValue,
      isFullTags
    } = this.state;
    const renderTags = [];
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => ({
        isRenderInTag: true,
        content: optionNode.label
      });
    }

    let mapItems = [];
    let tags = [];
    let tagContent;

    if (!_isNumber(maxTagCount)) {
      // maxTagCount is not set, all tags are displayed
      mapItems = selectedItems;
      tags = mapItems.map((item, i) => {
        return this.getTagItem(item, i, renderSelectedItem);
      });
      tagContent = tags;
    } else {
      // maxTagCount is set
      if (showRestTagsPopover) {
        // showRestTagsPopover = true，
        mapItems = isFullTags ? selectedItems : selectedItems.slice(0, maxTagCount);
        tags = mapItems.map((item, i) => {
          return this.getTagItem(item, i, renderSelectedItem);
        });
        const n = selectedItems.length > maxTagCount ? maxTagCount : undefined;
        tagContent = /*#__PURE__*/React.createElement(TagGroup, {
          tagList: tags,
          maxTagCount: n,
          restCount: isFullTags ? undefined : selectedItems.length - maxTagCount,
          size: "large",
          mode: "custom",
          showPopover: showRestTagsPopover,
          popoverProps: restTagsPopoverProps,
          onPlusNMouseEnter: () => {
            this.foundation.updateIsFullTags();
          }
        });
      } else {
        // If maxTagCount is set, showRestTagsPopover is false/undefined, 
        // then there is no popover when hovering, no extra Tags are displayed, 
        // only the tags and restCount displayed in the trigger need to be passed in
        mapItems = selectedItems.slice(0, maxTagCount);
        const n = selectedItems.length > maxTagCount ? maxTagCount : undefined;
        tags = mapItems.map((item, i) => {
          return this.getTagItem(item, i, renderSelectedItem);
        });
        tagContent = /*#__PURE__*/React.createElement(TagGroup, {
          tagList: tags,
          maxTagCount: n,
          restCount: selectedItems.length - maxTagCount,
          size: "large",
          mode: "custom"
        });
      }
    }

    const contentWrapperCls = cls({
      ["".concat(prefixcls, "-content-wrapper")]: true,
      ["".concat(prefixcls, "-content-wrapper-one-line")]: maxTagCount,
      ["".concat(prefixcls, "-content-wrapper-empty")]: !tags.length
    });
    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !tags.length,
      ["".concat(prefixcls, "-selection-text-hide")]: tags && tags.length // [prefixcls + '-selection-text-inactive']: !inputValue && !tags.length,

    });
    const placeholderText = placeholder && !inputValue ? /*#__PURE__*/React.createElement("span", {
      className: spanCls
    }, placeholder) : null;
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, tags && tags.length ? tagContent : placeholderText, !filterable ? null : this.renderInput()));
  }

  onMouseEnter(e) {
    this.foundation.handleMouseEnter(e);
  }

  onMouseLeave(e) {
    this.foundation.handleMouseLeave(e);
  }

  onKeyPress(e) {
    this.foundation.handleKeyPress(e);
  }
  /* Processing logic when popover visible changes */


  handlePopoverVisibleChange(status) {
    const {
      virtualize
    } = this.props;
    const {
      selections
    } = this.state;

    if (!status) {
      return;
    }

    if (virtualize) {
      let minItemIndex = -1;
      selections.forEach(item => {
        const itemIndex = _get(item, '_scrollIndex');
        /* When the itemIndex is legal */


        if (_isNumber(itemIndex) && itemIndex >= 0) {
          minItemIndex = minItemIndex !== -1 && minItemIndex < itemIndex ? minItemIndex : itemIndex;
        }
      });

      if (minItemIndex !== -1) {
        try {
          this.virtualizeListRef.current.scrollToItem(minItemIndex, 'center');
        } catch (error) {}
      }
    } else {
      this.foundation.updateScrollTop();
    }
  }

  renderSuffix() {
    const {
      suffix
    } = this.props;
    const suffixWrapperCls = cls({
      ["".concat(prefixcls, "-suffix")]: true,
      ["".concat(prefixcls, "-suffix-text")]: suffix && _isString(suffix),
      ["".concat(prefixcls, "-suffix-icon")]: isSemiIcon(suffix)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: suffixWrapperCls,
      "x-semi-prop": "suffix"
    }, suffix);
  }

  renderPrefix() {
    const {
      prefix,
      insetLabel,
      insetLabelId
    } = this.props;
    const labelNode = prefix || insetLabel;
    const prefixWrapperCls = cls({
      ["".concat(prefixcls, "-prefix")]: true,
      ["".concat(prefixcls, "-inset-label")]: insetLabel,
      ["".concat(prefixcls, "-prefix-text")]: labelNode && _isString(labelNode),
      ["".concat(prefixcls, "-prefix-icon")]: isSemiIcon(labelNode)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: prefixWrapperCls,
      id: insetLabelId,
      "x-semi-prop": "prefix,insetLabel"
    }, labelNode);
  }

  renderSelection() {
    const {
      disabled,
      multiple,
      filter,
      style,
      id,
      size,
      className,
      validateStatus,
      showArrow,
      suffix,
      prefix,
      insetLabel,
      placeholder,
      triggerRender,
      arrowIcon
    } = this.props;
    const {
      selections,
      isOpen,
      keyboardEventSet,
      inputValue,
      isHovering,
      isFocus,
      showInput,
      focusIndex
    } = this.state;
    const useCustomTrigger = typeof triggerRender === 'function';
    const filterable = Boolean(filter); // filter（boolean || function）

    const selectionCls = useCustomTrigger ? cls(className) : cls(prefixcls, className, {
      ["".concat(prefixcls, "-open")]: isOpen,
      ["".concat(prefixcls, "-focus")]: isFocus,
      ["".concat(prefixcls, "-disabled")]: disabled,
      ["".concat(prefixcls, "-single")]: !multiple,
      ["".concat(prefixcls, "-multiple")]: multiple,
      ["".concat(prefixcls, "-filterable")]: filterable,
      ["".concat(prefixcls, "-small")]: size === 'small',
      ["".concat(prefixcls, "-large")]: size === 'large',
      ["".concat(prefixcls, "-error")]: validateStatus === 'error',
      ["".concat(prefixcls, "-warning")]: validateStatus === 'warning',
      ["".concat(prefixcls, "-no-arrow")]: !showArrow,
      ["".concat(prefixcls, "-with-prefix")]: prefix || insetLabel,
      ["".concat(prefixcls, "-with-suffix")]: suffix
    });
    const showClear = this.props.showClear && (selections.size || inputValue) && !disabled && (isHovering || isOpen);
    const arrowContent = showArrow ? /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow"),
      "x-semi-prop": "arrowIcon"
    }, arrowIcon) : /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow-empty")
    });
    const inner = useCustomTrigger ? /*#__PURE__*/React.createElement(Trigger, {
      value: Array.from(selections.values()),
      inputValue: inputValue,
      onChange: this.handleInputChange,
      onClear: this.onClear,
      disabled: disabled,
      triggerRender: triggerRender,
      placeholder: placeholder,
      componentName: "Select",
      componentProps: Object.assign({}, this.props)
    }) : [/*#__PURE__*/React.createElement(Fragment, {
      key: "prefix"
    }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/React.createElement(Fragment, {
      key: "selection"
    }, /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-selection"))
    }, multiple ? this.renderMultipleSelection(selections, filterable) : this.renderSingleSelection(selections, filterable))), /*#__PURE__*/React.createElement(Fragment, {
      key: "clearicon"
    }, showClear ? /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-clear")),
      onClick: this.onClear
    }, /*#__PURE__*/React.createElement(IconClear, null)) : arrowContent), /*#__PURE__*/React.createElement(Fragment, {
      key: "suffix"
    }, suffix ? this.renderSuffix() : null)];
    /**
     *
     * In disabled, searchable single-selection and display input, and searchable multi-selection
     * make combobox not focusable by tab key
     *
     * 在disabled，可搜索单选且显示input框，以及可搜索多选情况下
     * 让combobox无法通过tab聚焦
     */

    const tabIndex = disabled || filterable && showInput || filterable && multiple ? -1 : 0;
    return (
      /*#__PURE__*/

      /* eslint-disable-next-line jsx-a11y/aria-activedescendant-has-tabindex */
      React.createElement("div", Object.assign({
        role: "combobox",
        "aria-disabled": disabled,
        "aria-expanded": isOpen,
        "aria-controls": "".concat(prefixcls, "-").concat(this.selectOptionListID),
        "aria-haspopup": "listbox",
        "aria-label": selections.size ? 'selected' : '',
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required'],
        className: selectionCls,
        ref: ref => this.triggerRef.current = ref,
        onClick: e => this.foundation.handleClick(e),
        style: style,
        id: this.selectID,
        tabIndex: tabIndex,
        "aria-activedescendant": focusIndex !== -1 ? "".concat(this.selectID, "-option-").concat(focusIndex) : '',
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave,
        onFocus: e => this.foundation.handleTriggerFocus(e),
        onBlur: e => this.foundation.handleTriggerBlur(e),
        onKeyPress: this.onKeyPress
      }, keyboardEventSet), inner)
    );
  }

  render() {
    const {
      direction
    } = this.context;
    const defaultPosition = direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    const {
      children,
      position = defaultPosition,
      zIndex,
      getPopupContainer,
      motion,
      autoAdjustOverflow,
      mouseLeaveDelay,
      mouseEnterDelay,
      spacing,
      stopPropagation
    } = this.props;
    const {
      isOpen,
      optionKey
    } = this.state;
    const optionList = this.renderOptions(children);
    const selection = this.renderSelection();
    return /*#__PURE__*/React.createElement(Popover, {
      getPopupContainer: getPopupContainer,
      motion: motion,
      autoAdjustOverflow: autoAdjustOverflow,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      // transformFromCenter TODO: check no such property
      zIndex: zIndex,
      ref: this.optionsRef,
      content: optionList,
      visible: isOpen,
      trigger: "custom",
      rePosKey: optionKey,
      position: position,
      spacing: spacing,
      stopPropagation: stopPropagation,
      disableArrowKeyDown: true,
      onVisibleChange: status => this.handlePopoverVisibleChange(status),
      afterClose: () => this.foundation.handlePopoverClose()
    }, selection);
  }

}

Select.contextType = ConfigContext;
Select.Option = Option;
Select.OptGroup = OptionGroup;
Select.propTypes = {
  'aria-describedby': PropTypes.string,
  'aria-errormessage': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-labelledby': PropTypes.string,
  'aria-required': PropTypes.bool,
  autoFocus: PropTypes.bool,
  autoClearSearchValue: PropTypes.bool,
  children: PropTypes.node,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  placeholder: PropTypes.node,
  onChange: PropTypes.func,
  multiple: PropTypes.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filter: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  // How many tags can you choose?
  max: PropTypes.number,
  // How many tabs are displayed at most, and the rest are displayed in + N
  maxTagCount: PropTypes.number,
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  style: PropTypes.object,
  className: PropTypes.string,
  size: PropTypes.oneOf(strings.SIZE_SET),
  disabled: PropTypes.bool,
  emptyContent: PropTypes.node,
  onDropdownVisibleChange: PropTypes.func,
  zIndex: PropTypes.number,
  position: PropTypes.oneOf(strings.POSITION_SET),
  onSearch: PropTypes.func,
  getPopupContainer: PropTypes.func,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  outerTopSlot: PropTypes.node,
  innerTopSlot: PropTypes.node,
  inputProps: PropTypes.object,
  outerBottomSlot: PropTypes.node,
  innerBottomSlot: PropTypes.node,
  optionList: PropTypes.array,
  dropdownMatchSelectWidth: PropTypes.bool,
  loading: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  validateStatus: PropTypes.oneOf(strings.STATUS),
  defaultActiveFirstOption: PropTypes.bool,
  triggerRender: PropTypes.func,
  stopPropagation: PropTypes.bool,
  // motion doesn't need to be exposed
  motion: PropTypes.bool,
  onChangeWithObject: PropTypes.bool,
  suffix: PropTypes.node,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  showClear: PropTypes.bool,
  showArrow: PropTypes.bool,
  renderSelectedItem: PropTypes.func,
  allowCreate: PropTypes.bool,
  renderCreateItem: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  clickToHide: PropTypes.bool,
  onExceed: PropTypes.func,
  onCreate: PropTypes.func,
  remote: PropTypes.bool,
  onDeselect: PropTypes.func,
  // The main difference between onSelect and onChange is that when multiple selections are selected, onChange contains all options, while onSelect only contains items for the current operation
  onSelect: PropTypes.func,
  autoAdjustOverflow: PropTypes.bool,
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  spacing: PropTypes.number,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onClear: PropTypes.func,
  virtualize: PropTypes.object,
  renderOptionItem: PropTypes.func,
  onListScroll: PropTypes.func,
  arrowIcon: PropTypes.node,
  preventScroll: PropTypes.bool // open: PropTypes.bool,
  // tagClosable: PropTypes.bool,

};
Select.defaultProps = {
  stopPropagation: true,
  motion: true,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  // position: 'bottomLeft',
  filter: false,
  multiple: false,
  disabled: false,
  defaultOpen: false,
  allowCreate: false,
  placeholder: '',
  onDropdownVisibleChange: _noop,
  onChangeWithObject: false,
  onChange: _noop,
  onSearch: _noop,
  onMouseEnter: _noop,
  onMouseLeave: _noop,
  onDeselect: _noop,
  onSelect: _noop,
  onCreate: _noop,
  onExceed: _noop,
  onFocus: _noop,
  onBlur: _noop,
  onClear: _noop,
  onListScroll: _noop,
  maxHeight: numbers.LIST_HEIGHT,
  dropdownMatchSelectWidth: true,
  defaultActiveFirstOption: true,
  showArrow: true,
  showClear: false,
  remote: false,
  autoAdjustOverflow: true,
  autoClearSearchValue: true,
  arrowIcon: /*#__PURE__*/React.createElement(IconChevronDown, {
    "aria-label": ''
  }),
  showRestTagsPopover: false,
  restTagsPopoverProps: {} // Radio selection is different from the default renderSelectedItem for multiple selection, so it is not declared here
  // renderSelectedItem: (optionNode) => optionNode.label,
  // The default creator rendering is related to i18, so it is not declared here
  // renderCreateItem: (input) => input

};
export default Select;