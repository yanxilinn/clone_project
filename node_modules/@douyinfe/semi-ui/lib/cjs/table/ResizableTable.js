"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _find2 = _interopRequireDefault(require("lodash/find"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _merge2 = _interopRequireDefault(require("lodash/merge"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = require("@douyinfe/semi-foundation/lib/cjs/utils/classnames");

var _constants = require("@douyinfe/semi-foundation/lib/cjs/table/constants");

var _utils = require("@douyinfe/semi-foundation/lib/cjs/table/utils");

var _Table = _interopRequireDefault(require("./Table"));

var _utils2 = require("./utils");

var _getColumns = _interopRequireDefault(require("./getColumns"));

var _ResizableHeaderCell = _interopRequireDefault(require("./ResizableHeaderCell"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable max-len */

/* eslint-disable @typescript-eslint/no-shadow */

/* eslint-disable react-hooks/exhaustive-deps */

/* eslint-disable react/destructuring-assignment */

/* eslint-disable max-lines-per-function */


const ResizableTable = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let ref = arguments.length > 1 ? arguments[1] : undefined;

  const {
    components: propComponents,
    columns: propColumns,
    resizable
  } = props,
        restProps = __rest(props, ["components", "columns", "resizable"]);

  const childrenColumnName = 'children';
  const onResize = (0, _get2.default)(resizable, 'onResize', _noop2.default);
  const onResizeStart = (0, _get2.default)(resizable, 'onResizeStart', _noop2.default);
  const onResizeStop = (0, _get2.default)(resizable, 'onResizeStop', _noop2.default);
  /**
   * 此处关于 columns 有三个存储
   *
   * 1. rawColumns 是根据 props.columns 或者 props.children 解析出来的原始 columns
   * 2. newColumns 是 rawColumns 的深拷贝，同时根据 props.expandedRowRender、props.hideExpandedColumn 和 props.rowSelection
   * 这三个参数加入了【选择列】以及【展开列】
   * 3. columns 是当前组件中存储的 state，一般情况下与 newColumns 相等，但是会保存列当前伸缩的宽度
   */

  /**
    * There are three stores for columns here
    *
    * 1. rawColumns are the original columns parsed according to props.columns or props.children
    * 2. newColumns is a deep copy of rawColumns, based on props.expandedRowRender, props.hideExpandedColumn and props.rowSelection
    * These three parameters have been added [Select Column] and [Expand Column]
    * 3. columns is the state stored in the current component, which is generally equal to newColumns, but it will save the current stretched width of the column
    */

  const parsedColumns = Array.isArray(propColumns) && propColumns.length ? propColumns : (0, _getColumns.default)(props.children);
  const rawColumns = (0, _utils.assignColumnKeys)((0, _utils2.cloneDeep)(parsedColumns), childrenColumnName);
  const newColumns = (0, _utils.assignColumnKeys)((0, _utils2.cloneDeep)(parsedColumns), childrenColumnName);

  if (typeof props.expandedRowRender === 'function' && !props.hideExpandedColumn && !(0, _find2.default)(rawColumns, item => item.key === _constants.strings.DEFAULT_KEY_COLUMN_EXPAND)) {
    newColumns.unshift({
      key: _constants.strings.DEFAULT_KEY_COLUMN_EXPAND,
      width: _constants.numbers.DEFAULT_WIDTH_COLUMN_EXPAND
    });
  }

  if (props.rowSelection && !(0, _find2.default)(rawColumns, item => item.key === _constants.strings.DEFAULT_KEY_COLUMN_SELECTION)) {
    newColumns.unshift({
      width: (0, _get2.default)(props, 'rowSelection.width', _constants.numbers.DEFAULT_WIDTH_COLUMN_SELECTION),
      key: _constants.strings.DEFAULT_KEY_COLUMN_SELECTION
    });
  }

  const [columns, setColumns] = (0, _react.useState)(newColumns);
  (0, _react.useEffect)(() => {
    // If there is a resize value, the width does not use the default value fix#1072
    const _newColumns = (0, _utils.withResizeWidth)(columns, newColumns);

    setColumns((0, _utils.mergeColumns)(columns, _newColumns));
  }, [propColumns, props.expandedRowRender, props.hideExpandedColumn, props.rowSelection]);
  const components = (0, _react.useMemo)(() => (0, _merge2.default)({
    header: {
      cell: _ResizableHeaderCell.default
    }
  }, propComponents), [propComponents]);
  const handlerClassName = (0, _get2.default)(resizable, 'handlerClassName', 'resizing');

  const handleResize = column => (e, _ref) => {
    let {
      size
    } = _ref;
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      width: size.width
    });
    const customProps = onResize(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };

  const handleResizeStart = column => e => {
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      className: (0, _classnames.addClass)(curColumn.className, handlerClassName)
    });
    const customProps = onResizeStart(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };

  const handleResizeStop = column => e => {
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      className: (0, _classnames.removeClass)(curColumn.className, handlerClassName)
    });
    const customProps = onResizeStop(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };

  const resizableRender = function (col, index) {
    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return Object.assign(Object.assign({}, col), {
      onHeaderCell: column => ({
        width: column.width,
        onResize: handleResize(column),
        onResizeStart: handleResizeStart(column),
        onResizeStop: handleResizeStop(column)
      })
    });
  };

  const assignResizableRender = function () {
    let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return Array.isArray(columns) && columns.length ? columns.map((col, index) => {
      Object.assign(col, resizableRender(col, index, level));
      const children = col[childrenColumnName];

      if (Array.isArray(children) && children.length) {
        col[childrenColumnName] = assignResizableRender(children, level + 1);
      }

      return col;
    }) : [];
  };

  const finalColumns = (0, _react.useMemo)(() => assignResizableRender(columns), [columns]);
  return /*#__PURE__*/_react.default.createElement(_Table.default, Object.assign({}, restProps, {
    columns: finalColumns,
    components: components,
    ref: ref
  }));
};

var _default = /*#__PURE__*/_react.default.forwardRef(ResizableTable);

exports.default = _default;