"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _constants = require("@douyinfe/semi-foundation/lib/cjs/cascader/constants");

var _isEnterPress = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/isEnterPress"));

var _context = _interopRequireDefault(require("../configProvider/context"));

var _localeConsumer = _interopRequireDefault(require("../locale/localeConsumer"));

var _semiIcons = require("@douyinfe/semi-icons");

var _spin = _interopRequireDefault(require("../spin"));

var _checkbox = _interopRequireDefault(require("../checkbox"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const prefixcls = _constants.cssClasses.PREFIX_OPTION;

class Item extends _react.PureComponent {
  constructor() {
    super(...arguments);

    this.onClick = (e, item) => {
      const {
        onItemClick
      } = this.props;

      if (item.data.disabled || 'disabled' in item && item.disabled) {
        return;
      }

      onItemClick(e, item);
    };
    /**
     * A11y: simulate item click
     */


    this.handleItemEnterPress = (keyboardEvent, item) => {
      if ((0, _isEnterPress.default)(keyboardEvent)) {
        this.onClick(keyboardEvent, item);
      }
    };

    this.onHover = (e, item) => {
      const {
        showNext,
        onItemHover
      } = this.props;

      if (item.data.disabled) {
        return;
      }

      if (showNext === _constants.strings.SHOW_NEXT_BY_HOVER) {
        onItemHover(e, item);
      }
    };

    this.onCheckboxChange = (e, item) => {
      const {
        onItemCheckboxClick
      } = this.props; // Prevent Checkbox's click event bubbling to trigger the li click event

      e.stopPropagation();

      if (e.nativeEvent && typeof e.nativeEvent.stopImmediatePropagation === 'function') {
        e.nativeEvent.stopImmediatePropagation();
      }

      onItemCheckboxClick(item);
    };

    this.getItemStatus = key => {
      const {
        activeKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys
      } = this.props;
      const state = {
        active: false,
        selected: false,
        loading: false
      };

      if (activeKeys.has(key)) {
        state.active = true;
      }

      if (selectedKeys.has(key)) {
        state.selected = true;
      }

      if (loadingKeys.has(key) && !loadedKeys.has(key)) {
        state.loading = true;
      }

      return state;
    };

    this.renderIcon = function (type) {
      let haveMarginLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      const finalCls = style => {
        return style + (haveMarginLeft ? " ".concat(prefixcls, "-icon-left") : '');
      };

      switch (type) {
        case 'child':
          return /*#__PURE__*/_react.default.createElement(_semiIcons.IconChevronRight, {
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-expand"))
          });

        case 'tick':
          return /*#__PURE__*/_react.default.createElement(_semiIcons.IconTick, {
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-active"))
          });

        case 'loading':
          return /*#__PURE__*/_react.default.createElement(_spin.default, {
            wrapperClassName: finalCls("".concat(prefixcls, "-spin-icon"))
          });

        case 'empty':
          return /*#__PURE__*/_react.default.createElement("span", {
            "aria-hidden": true,
            className: finalCls("".concat(prefixcls, "-icon ").concat(prefixcls, "-icon-empty"))
          });

        default:
          return null;
      }
    };

    this.highlight = searchText => {
      const content = [];
      const {
        keyword,
        separator
      } = this.props;
      searchText.forEach((item, idx) => {
        if (typeof item === 'string' && (0, _includes2.default)(item, keyword)) {
          item.split(keyword).forEach((node, index) => {
            if (index > 0) {
              content.push( /*#__PURE__*/_react.default.createElement("span", {
                className: "".concat(prefixcls, "-label-highlight"),
                key: "".concat(index, "-").concat(idx)
              }, keyword));
            }

            content.push(node);
          });
        } else {
          content.push(item);
        }

        if (idx !== searchText.length - 1) {
          content.push(separator);
        }
      });
      return content;
    };

    this.renderFlattenOption = data => {
      const {
        multiple,
        checkedKeys,
        halfCheckedKeys
      } = this.props;

      const content = /*#__PURE__*/_react.default.createElement("ul", {
        className: "".concat(prefixcls, "-list"),
        key: 'flatten-list'
      }, data.map(item => {
        const {
          searchText,
          key,
          disabled
        } = item;
        const className = (0, _classnames.default)(prefixcls, {
          ["".concat(prefixcls, "-flatten")]: true,
          ["".concat(prefixcls, "-disabled")]: disabled
        });
        return /*#__PURE__*/_react.default.createElement("li", {
          role: 'menuitem',
          className: className,
          key: key,
          onClick: e => {
            this.onClick(e, item);
          },
          onKeyPress: e => this.handleItemEnterPress(e, item)
        }, /*#__PURE__*/_react.default.createElement("span", {
          className: "".concat(prefixcls, "-label")
        }, !multiple && this.renderIcon('empty'), multiple && /*#__PURE__*/_react.default.createElement(_checkbox.default, {
          onChange: e => this.onCheckboxChange(e, item),
          disabled: disabled,
          indeterminate: halfCheckedKeys.has(item.key),
          checked: checkedKeys.has(item.key),
          className: "".concat(prefixcls, "-label-checkbox")
        }), this.highlight(searchText)));
      }));

      return content;
    };
  }

  renderItem(renderData) {
    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const {
      multiple,
      checkedKeys,
      halfCheckedKeys
    } = this.props;
    let showChildItem;
    const ind = content.length;
    content.push( /*#__PURE__*/_react.default.createElement("ul", {
      role: 'menu',
      className: "".concat(prefixcls, "-list"),
      key: renderData[0].key,
      onScroll: e => this.props.onListScroll(e, ind)
    }, renderData.map(item => {
      const {
        data,
        key,
        parentKey
      } = item;
      const {
        children,
        label,
        disabled,
        isLeaf
      } = data;
      const {
        active,
        selected,
        loading
      } = this.getItemStatus(key);
      const hasChild = Boolean(children) && children.length;
      const showExpand = hasChild || this.props.loadData && !isLeaf;

      if (active && hasChild) {
        showChildItem = item;
      }

      const className = (0, _classnames.default)(prefixcls, {
        ["".concat(prefixcls, "-active")]: active && !selected,
        ["".concat(prefixcls, "-select")]: selected && !multiple,
        ["".concat(prefixcls, "-disabled")]: disabled
      });
      const otherAriaProps = parentKey ? {
        ['aria-owns']: "cascaderItem-".concat(parentKey)
      } : {};
      return /*#__PURE__*/_react.default.createElement("li", Object.assign({
        role: 'menuitem',
        id: "cascaderItem-".concat(key),
        "aria-expanded": active,
        "aria-haspopup": Boolean(showExpand),
        "aria-disabled": disabled
      }, otherAriaProps, {
        className: className,
        key: key,
        onClick: e => {
          this.onClick(e, item);
        },
        onKeyPress: e => this.handleItemEnterPress(e, item),
        onMouseEnter: e => {
          this.onHover(e, item);
        }
      }), /*#__PURE__*/_react.default.createElement("span", {
        className: "".concat(prefixcls, "-label")
      }, selected && !multiple && this.renderIcon('tick'), !selected && !multiple && this.renderIcon('empty'), multiple && /*#__PURE__*/_react.default.createElement(_checkbox.default, {
        onChange: e => this.onCheckboxChange(e, item),
        disabled: disabled,
        indeterminate: halfCheckedKeys.has(item.key),
        checked: checkedKeys.has(item.key),
        className: "".concat(prefixcls, "-label-checkbox")
      }), /*#__PURE__*/_react.default.createElement("span", null, label)), showExpand ? this.renderIcon(loading ? 'loading' : 'child', true) : null);
    })));

    if (showChildItem) {
      content.concat(this.renderItem(showChildItem.children, content));
    }

    return content;
  }

  renderEmpty() {
    const {
      emptyContent
    } = this.props;
    return /*#__PURE__*/_react.default.createElement(_localeConsumer.default, {
      componentName: "Cascader"
    }, locale => /*#__PURE__*/_react.default.createElement("ul", {
      className: "".concat(prefixcls, " ").concat(prefixcls, "-empty"),
      key: 'empty-list'
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "".concat(prefixcls, "-label"),
      "x-semi-prop": "emptyContent"
    }, emptyContent || locale.emptyText)));
  }

  render() {
    const {
      data,
      searchable
    } = this.props;
    const {
      direction
    } = this.context;
    const isEmpty = !data || !data.length;
    let content;
    const listsCls = (0, _classnames.default)({
      ["".concat(prefixcls, "-lists")]: true,
      ["".concat(prefixcls, "-lists-rtl")]: direction === 'rtl',
      ["".concat(prefixcls, "-lists-empty")]: isEmpty
    });

    if (isEmpty) {
      content = this.renderEmpty();
    } else {
      content = searchable ? this.renderFlattenOption(data) : this.renderItem(data);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: listsCls
    }, content);
  }

}

exports.default = Item;
Item.contextType = _context.default;
Item.propTypes = {
  data: _propTypes.default.array,
  emptyContent: _propTypes.default.node,
  searchable: _propTypes.default.bool,
  onItemClick: _propTypes.default.func,
  onItemHover: _propTypes.default.func,
  multiple: _propTypes.default.bool,
  showNext: _propTypes.default.oneOf([_constants.strings.SHOW_NEXT_BY_CLICK, _constants.strings.SHOW_NEXT_BY_HOVER]),
  checkedKeys: _propTypes.default.object,
  halfCheckedKeys: _propTypes.default.object,
  onItemCheckboxClick: _propTypes.default.func,
  separator: _propTypes.default.string,
  keyword: _propTypes.default.string
};
Item.defaultProps = {
  empty: false
};