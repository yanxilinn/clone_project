"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _react = _interopRequireWildcard(require("react"));

var _uuid = require("@douyinfe/semi-foundation/lib/cjs/utils/uuid");

var _context = require("./context");

var _warning = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/warning"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable react/destructuring-assignment */
const filterArrayByIndex = (array, index) => array.filter((item, i) => i !== index);

const getUuidByArray = array => array.map(() => (0, _uuid.getUuidv4)());

const getUpdateKey = arrayField => {
  if (!arrayField) {
    return undefined;
  }

  if (arrayField && arrayField.updateKey) {
    return arrayField.updateKey;
  }

  return undefined;
};

const initValueAdapter = initValue => {
  const iv = [];

  if (Array.isArray(initValue)) {
    return initValue;
  } else {
    (0, _warning.default)(!(0, _isUndefined2.default)(initValue), '[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props');
    return iv;
  }
};
/**
 *
 * @param {any[]} value
 * @param {string[]} oldKeys
 * @returns string[]
 */


const generateKeys = (value, oldKeys) => {
  const val = initValueAdapter(value);
  const newKeys = getUuidByArray(val); // return newKeys;

  const keys = newKeys.map((key, i) => oldKeys && oldKeys[i] ? oldKeys[i] : key);
  return keys;
};

class ArrayFieldComponent extends _react.Component {
  constructor(props, context) {
    super(props, context);
    const initValueInProps = this.props.initValue;
    const {
      field
    } = this.props;
    const initValueInForm = context.getValue(field);
    const initValue = initValueInProps || initValueInForm;
    this.state = {
      keys: generateKeys(initValue)
    };
    this.add = this.add.bind(this);
    this.addWithInitValue = this.addWithInitValue.bind(this);
    this.remove = this.remove.bind(this);
    this.cacheFieldValues = null;
    this.cacheUpdateKey = null;
    /*
        If updateKey exists, it means that the arrayField (usually a nested ArrayField not at the first level) is only re-mounted due to setValues,
        and the fields it contains do not need to consume initValue
    */
    // whether the fields inside arrayField should use props.initValue in current render process

    this.shouldUseInitValue = !context.getArrayField(field); // Separate the arrays that reset and the usual add and remove modify, otherwise they will affect each other

    const initValueCopyForFormState = (0, _cloneDeep2.default)(initValue);
    const initValueCopyForReset = (0, _cloneDeep2.default)(initValue);
    context.registerArrayField(field, initValueCopyForReset); // register ArrayField will update state.updateKey to render, So there is no need to execute forceUpdate here

    context.updateStateValue(field, initValueCopyForFormState, {
      notNotify: true,
      notUpdate: true
    });
  }

  componentWillUnmount() {
    const updater = this.context;
    const {
      field
    } = this.props;
    updater.unRegisterArrayField(field);
  }

  componentDidUpdate() {
    const updater = this.context;
    const {
      field
    } = this.props;
    const {
      keys
    } = this.state;
    const fieldValues = updater.getValue(field);
    const updateKey = getUpdateKey(updater.getArrayField(field)); // when update form outside, like use formApi.setValue('field', [{newItem1, newItem2}]),  formApi.setValues
    // re generate keys to update arrayField;

    if (updateKey !== this.cacheUpdateKey) {
      const newKeys = generateKeys(fieldValues, keys); // eslint-disable-next-line

      this.setState({
        keys: newKeys
      });
      this.cacheUpdateKey = updateKey;

      if (this.cacheUpdateKey !== null) {
        this.shouldUseInitValue = false;
      }
    }
  }

  add() {
    const {
      keys
    } = this.state;
    keys.push((0, _uuid.getUuidv4)());
    this.shouldUseInitValue = true;
    this.setState({
      keys
    });
  }

  addWithInitValue(lineObject) {
    const updater = this.context;
    const {
      field
    } = this.props;
    const newArrayFieldVal = updater.getValue(field) ? updater.getValue(field).slice() : [];
    newArrayFieldVal.push(lineObject);
    updater.updateStateValue(field, newArrayFieldVal, {});
    updater.updateArrayField(field, {
      updateKey: new Date().valueOf()
    });
  }

  remove(i) {
    const updater = this.context;
    const {
      keys
    } = this.state;
    const {
      field
    } = this.props;
    const newKeys = filterArrayByIndex(keys, i); // Make sure that all the keys in the line are removed, because some keys are not taken over by the field, only set in the initValue

    let newArrayFieldError = updater.getError(field);
    const opts = {
      notNotify: true,
      notUpdate: true
    };

    if (Array.isArray(newArrayFieldError)) {
      newArrayFieldError = newArrayFieldError.slice();
      newArrayFieldError.splice(i, 1);
      updater.updateStateError(field, newArrayFieldError, opts);
    } // if (Array.isArray(newArrayFieldTouched)) {
    //     newArrayFieldTouched = newArrayFieldTouched.slice();
    //     newArrayFieldTouched.splice(i, 1);
    //     updater.updateStateTouched(field, newArrayFieldTouched, opts);
    // }


    let newArrayFieldValue = updater.getValue(field);

    if (Array.isArray(newArrayFieldValue)) {
      newArrayFieldValue = newArrayFieldValue.slice();
      newArrayFieldValue.splice(i, 1);
      updater.updateStateValue(field, newArrayFieldValue);
    }

    this.setState({
      keys: newKeys
    });
  }

  render() {
    const {
      children,
      field
    } = this.props;
    const {
      keys
    } = this.state;
    const arrayFields = keys.map((key, i) => ({
      // key: i,
      key,
      field: "".concat(field, "[").concat(i, "]"),
      remove: () => this.remove(i)
    }));
    const {
      add
    } = this;
    const {
      addWithInitValue
    } = this;
    const contextVal = {
      shouldUseInitValue: this.shouldUseInitValue
    };
    return /*#__PURE__*/_react.default.createElement(_context.ArrayFieldContext.Provider, {
      value: contextVal
    }, children({
      arrayFields,
      add,
      addWithInitValue
    }));
  }

}

ArrayFieldComponent.contextType = _context.FormUpdaterContext;
var _default = ArrayFieldComponent;
exports.default = _default;