"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireDefault(require("react"));

var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/collapsible/foundation"));

var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _constants = require("@douyinfe/semi-foundation/lib/cjs/collapsible/constants");

require("@douyinfe/semi-foundation/lib/cjs/collapsible/collapsible.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Collapsible extends _baseComponent.default {
  constructor(props) {
    super(props);
    this.domRef = /*#__PURE__*/_react.default.createRef();

    this.handleResize = entryList => {
      const entry = entryList[0];

      if (entry) {
        const entryInfo = Collapsible.getEntryInfo(entry);
        this.foundation.updateDOMHeight(entryInfo.height);
        this.foundation.updateDOMInRenderTree(entryInfo.isShown);
      }
    };

    this.isChildrenInRenderTree = () => {
      if (this.domRef.current) {
        return this.domRef.current.offsetHeight > 0;
      } else {
        return false;
      }
    };

    this.state = {
      domInRenderTree: false,
      domHeight: 0,
      visible: this.props.isOpen,
      isTransitioning: false
    };
    this.foundation = new _foundation.default(this.adapter);
  }

  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      setDOMInRenderTree: domInRenderTree => {
        if (this.state.domInRenderTree !== domInRenderTree) {
          this.setState({
            domInRenderTree
          });
        }
      },
      setDOMHeight: domHeight => {
        if (this.state.domHeight !== domHeight) {
          this.setState({
            domHeight
          });
        }
      },
      setVisible: visible => {
        if (this.state.visible !== visible) {
          this.setState({
            visible
          });
        }
      },
      setIsTransitioning: isTransitioning => {
        if (this.state.isTransitioning !== isTransitioning) {
          this.setState({
            isTransitioning
          });
        }
      }
    });
  }

  componentDidMount() {
    super.componentDidMount();
    this.resizeObserver = new ResizeObserver(this.handleResize);
    this.resizeObserver.observe(this.domRef.current);
    const domInRenderTree = this.isChildrenInRenderTree();
    this.foundation.updateDOMInRenderTree(domInRenderTree);

    if (domInRenderTree) {
      this.foundation.updateDOMHeight(this.domRef.current.scrollHeight);
    }
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const changedPropKeys = Object.keys(this.props).filter(key => !(0, _isEqual2.default)(this.props[key], prevProps[key]));
    const changedStateKeys = Object.keys(this.state).filter(key => !(0, _isEqual2.default)(this.state[key], prevState[key]));

    if (changedPropKeys.includes("reCalcKey")) {
      this.foundation.updateDOMHeight(this.domRef.current.scrollHeight);
    }

    if (changedStateKeys.includes("domInRenderTree") && this.state.domInRenderTree) {
      this.foundation.updateDOMHeight(this.domRef.current.scrollHeight);
    }

    if (changedPropKeys.includes("isOpen")) {
      if (this.props.isOpen || !this.props.motion) {
        this.foundation.updateVisible(this.props.isOpen);
      }
    }

    if (this.props.motion && prevProps.isOpen !== this.props.isOpen) {
      this.foundation.updateIsTransitioning(true);
    }
  }

  componentWillUnmount() {
    super.componentWillUnmount();
    this.resizeObserver.disconnect();
  }

  render() {
    const wrapperStyle = Object.assign({
      overflow: 'hidden',
      height: this.props.isOpen ? this.state.domHeight : this.props.collapseHeight,
      opacity: this.props.isOpen || !this.props.fade || this.props.collapseHeight !== 0 ? 1 : 0,
      transitionDuration: "".concat(this.props.motion && this.state.isTransitioning ? this.props.duration : 0, "ms")
    }, this.props.style);
    const wrapperCls = (0, _classnames.default)("".concat(_constants.cssClasses.PREFIX, "-wrapper"), {
      ["".concat(_constants.cssClasses.PREFIX, "-transition")]: this.props.motion && this.state.isTransitioning
    }, this.props.className);
    return /*#__PURE__*/_react.default.createElement("div", {
      className: wrapperCls,
      style: wrapperStyle,
      onTransitionEnd: () => {
        var _a, _b;

        if (!this.props.isOpen) {
          this.foundation.updateVisible(false);
        }

        this.foundation.updateIsTransitioning(false);
        (_b = (_a = this.props).onMotionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    }, /*#__PURE__*/_react.default.createElement("div", {
      "x-semi-prop": "children",
      ref: this.domRef,
      style: {
        overflow: 'hidden'
      },
      id: this.props.id
    }, (this.props.keepDOM || this.props.collapseHeight !== 0 || this.state.visible || this.props.isOpen) && this.props.children));
  }

}

Collapsible.defaultProps = {
  isOpen: false,
  duration: 250,
  motion: true,
  keepDOM: false,
  collapseHeight: 0,
  fade: false
};

Collapsible.getEntryInfo = entry => {
  //judge whether parent or self display none
  let inRenderTree;

  if (entry.borderBoxSize) {
    inRenderTree = !(entry.borderBoxSize[0].blockSize === 0 && entry.borderBoxSize[0].inlineSize === 0);
  } else {
    inRenderTree = !(entry.contentRect.height === 0 && entry.contentRect.width === 0);
  }

  let height = 0;

  if (entry.borderBoxSize) {
    height = Math.ceil(entry.borderBoxSize[0].blockSize);
  } else {
    const target = entry.target;
    height = target.clientHeight;
  }

  return {
    isShown: inRenderTree,
    height
  };
};

Collapsible.propTypes = {
  motion: _propTypes.default.bool,
  children: _propTypes.default.node,
  isOpen: _propTypes.default.bool,
  duration: _propTypes.default.number,
  keepDOM: _propTypes.default.bool,
  collapseHeight: _propTypes.default.number,
  style: _propTypes.default.object,
  className: _propTypes.default.string,
  reCalcKey: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])
};
var _default = Collapsible;
exports.default = _default;