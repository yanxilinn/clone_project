"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcMergeType = calcMergeType;
exports.convertDataToEntities = convertDataToEntities;
exports.findKeysForValues = findKeysForValues;
exports.isValid = isValid;
exports.normalizedArr = normalizedArr;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _isNull2 = _interopRequireDefault(require("lodash/isNull"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}

function isValid(val) {
  return !(0, _isNull2.default)(val) && !(0, _isUndefined2.default)(val);
}

function normalizedArr(val) {
  if (!Array.isArray(val)) {
    return [val];
  } else {
    return val;
  }
}
/**
 * Traverse all the data by `treeData`.
 */


function traverseDataNodes(treeNodes, callback) {
  const processNode = (node, ind, parent) => {
    const children = node ? node.children : treeNodes;
    let item = null; // Process node if is not root

    if (node) {
      const key = parent ? getPosition(parent.key, ind) : "".concat(ind);
      item = {
        data: Object.assign({}, node),
        ind,
        key,
        level: parent ? parent.level + 1 : 0,
        parentKey: parent ? parent.key : null,
        path: parent ? [...parent.path, key] : [key],
        valuePath: parent ? [...parent.valuePath, node.value] : [node.value]
      };
      callback(item);
    } // Process children node


    if (children) {
      children.forEach((subNode, subIndex) => {
        processNode(subNode, subIndex, item);
      });
    }
  };

  processNode(null);
}

function convertDataToEntities(dataNodes) {
  const keyEntities = {};
  traverseDataNodes(dataNodes, data => {
    const {
      key,
      parentKey
    } = data;
    const entity = Object.assign({}, data);
    keyEntities[key] = entity; // Fill children

    entity.parent = keyEntities[parentKey];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
  });
  return keyEntities;
}

function findKeysForValues(value, keyEntities) {
  const valuePath = normalizedArr(value);
  const res = Object.values(keyEntities).filter(item => (0, _isEqual2.default)(item.valuePath, valuePath)).map(item => item.key);
  return res;
}

function calcMergeType(autoMergeValue, leafOnly) {
  let mergeType;

  if (leafOnly) {
    mergeType = _constants.strings.LEAF_ONLY_MERGE_TYPE;
  } else if (autoMergeValue) {
    mergeType = _constants.strings.AUTO_MERGE_VALUE_MERGE_TYPE;
  } else {
    mergeType = _constants.strings.NONE_MERGE_TYPE;
  }

  return mergeType;
}